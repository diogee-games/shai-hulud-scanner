#!/usr/bin/env bash
# =============================================================================
# purge-malware-from-history.sh
# =============================================================================
# Removes Shai-Hulud malware from git history using git-filter-repo.
#
# The malware hides after legitimate code on a line, separated by 50+ spaces:
#   `;\s{50,}eval("global['_V']='5-3-238';"+atob('...'))`
#
# This script rewrites every blob in history, stripping the whitespace+payload
# from any line that matches, preserving the clean code before it.
#
# Usage:
#   ./purge-malware-from-history.sh <repo-path>              # dry-run (default)
#   ./purge-malware-from-history.sh <repo-path> --execute     # actually rewrite
#
# Requirements:
#   - git-filter-repo (pip3 install git-filter-repo)
#   - Python 3.6+
#   - The shai-hulud scanner (detect-config-malware.sh) for verification
# =============================================================================

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCANNER="${SCRIPT_DIR}/detect-config-malware.sh"

# =============================================================================
# Functions
# =============================================================================

usage() {
    echo -e "${BOLD}Usage:${NC} $0 <repo-path> [--execute]"
    echo ""
    echo "  <repo-path>    Path to the git repository to clean"
    echo "  --execute       Actually rewrite history (default is dry-run)"
    echo ""
    echo "Examples:"
    echo "  $0 ~/clients                  # Dry-run: show what would change"
    echo "  $0 ~/clients --execute        # Rewrite history for real"
}

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

log_header() {
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════${NC}"
}

# =============================================================================
# Parse arguments
# =============================================================================

if [[ $# -lt 1 ]]; then
    usage
    exit 1
fi

REPO_PATH="$(realpath "$1")"
EXECUTE=false

if [[ "${2:-}" == "--execute" ]]; then
    EXECUTE=true
fi

# =============================================================================
# Pre-flight checks
# =============================================================================

log_header "Pre-flight Checks"

# Check git-filter-repo
if ! command -v git-filter-repo &>/dev/null; then
    log_error "git-filter-repo not found. Install with: pip3 install git-filter-repo"
    exit 1
fi
log_success "git-filter-repo found: $(which git-filter-repo)"

# Check repo exists
if [[ ! -d "${REPO_PATH}/.git" ]]; then
    log_error "${REPO_PATH} is not a git repository"
    exit 1
fi
log_success "Repository found: ${REPO_PATH}"

# Check scanner exists
if [[ ! -x "${SCANNER}" ]]; then
    log_warn "Scanner not found at ${SCANNER} — post-rewrite verification will be skipped"
    HAS_SCANNER=false
else
    log_success "Scanner found: ${SCANNER}"
    HAS_SCANNER=true
fi

# Check for uncommitted changes — stash if needed
cd "${REPO_PATH}"
STASHED=false
if ! git diff --quiet || ! git diff --cached --quiet; then
    log_warn "Repository has uncommitted changes — will stash them"
    git stash push -m "purge-malware-pre-rewrite-stash" --include-untracked
    STASHED=true
    log_success "Changes stashed"
else
    log_success "Working tree is clean"
fi

# =============================================================================
# Scan for infected blobs in history
# =============================================================================

log_header "Scanning History for Malware"

# Malware detection patterns — these match the Shai-Hulud payload
# Pattern: legitimate code, then 50+ spaces, then eval(...) payload
MALWARE_PATTERNS=(
    "eval.*global\[.*_V.*\]"
    "eval.*atob\("
    "global\[.*_V.*\].*atob"
    "global\.i=['\"][0-9]+-[0-9]+"
)

INFECTED_COMMITS=()
INFECTED_FILES=()

log_info "Searching all commits for malware patterns..."

# Find commits that have blobs matching malware patterns
for pattern in "${MALWARE_PATTERNS[@]}"; do
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            commit_hash=$(echo "$line" | cut -d: -f1)
            file_path=$(echo "$line" | cut -d: -f2-)
            if [[ ! " ${INFECTED_COMMITS[*]:-} " =~ " ${commit_hash} " ]]; then
                INFECTED_COMMITS+=("$commit_hash")
            fi
            entry="${commit_hash}:${file_path}"
            if [[ ! " ${INFECTED_FILES[*]:-} " =~ " ${entry} " ]]; then
                INFECTED_FILES+=("$entry")
            fi
        fi
    done < <(git log --all --format="%H" | while read -r commit; do
        git diff-tree --no-commit-id -r "$commit" 2>/dev/null | while read -r mode1 mode2 hash1 hash2 status filepath; do
            if [[ "$status" != "D" ]] && git show "${commit}:${filepath}" 2>/dev/null | grep -qE "$pattern" 2>/dev/null; then
                echo "${commit}:${filepath}"
            fi
        done
    done)
done

if [[ ${#INFECTED_FILES[@]} -eq 0 ]]; then
    log_success "No malware found in git history! Repository is clean."
    if [[ "$STASHED" == true ]]; then
        git stash pop >/dev/null 2>&1 || true
    fi
    exit 0
fi

echo ""
log_warn "Found ${#INFECTED_FILES[@]} infected file(s) across ${#INFECTED_COMMITS[@]} commit(s):"
echo ""
for entry in "${INFECTED_FILES[@]}"; do
    commit=$(echo "$entry" | cut -d: -f1)
    filepath=$(echo "$entry" | cut -d: -f2-)
    short_hash=$(echo "$commit" | cut -c1-7)
    commit_msg=$(git log -1 --format="%s" "$commit" 2>/dev/null)
    echo -e "  ${RED}${short_hash}${NC}  ${filepath}"
    echo -e "           ${YELLOW}${commit_msg}${NC}"
done

# Show what the malware looks like on the infected lines
echo ""
log_info "Malware payload preview (first infected file):"
first_entry="${INFECTED_FILES[0]}"
first_commit=$(echo "$first_entry" | cut -d: -f1)
first_file=$(echo "$first_entry" | cut -d: -f2-)
infected_line=$(git show "${first_commit}:${first_file}" | grep -nE '[^[:space:]][[:space:]]{50,}eval' | head -1 | cut -d: -f1)
if [[ -n "$infected_line" ]]; then
    line_content=$(git show "${first_commit}:${first_file}" | sed -n "${infected_line}p")
    clean_part=$(echo "$line_content" | sed 's/\([^[:space:]]\)[[:space:]]\{50,\}.*/\1/')
    payload_start=$(echo "$line_content" | grep -oP '(?<=\s{50})eval.{0,80}' | head -1)
    line_len=${#line_content}
    echo -e "  Line ${infected_line}: starts with ${CYAN}${clean_part}${NC}"
    echo -e "  Followed by whitespace, then: ${RED}${payload_start}...${NC}"
    echo -e "  Total line length: ${RED}${line_len} chars${NC} (normal: ~3 chars)"
fi

# =============================================================================
# Dry-run vs Execute
# =============================================================================

if [[ "$EXECUTE" != true ]]; then
    log_header "DRY RUN — No Changes Made"
    echo ""
    echo -e "  This was a ${BOLD}dry run${NC}. To actually rewrite history, run:"
    echo ""
    echo -e "    ${GREEN}$0 ${REPO_PATH} --execute${NC}"
    echo ""
    echo "  What will happen:"
    echo "    1. Tar backup the entire repo to a timestamped .tar.gz"
    echo "    2. Rewrite all blobs, stripping malware payloads"
    echo "    3. Restore remote URLs (git-filter-repo removes them)"
    echo "    4. Verify with scanner"
    echo "    5. Prompt for force-push"
    echo ""
    if [[ "$STASHED" == true ]]; then
        git stash pop >/dev/null 2>&1 || true
        log_info "Stashed changes restored"
    fi
    exit 0
fi

# =============================================================================
# Backup
# =============================================================================

log_header "Creating Backup"

REPO_NAME="$(basename "${REPO_PATH}")"
TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
BACKUP_TAR="${REPO_PATH}/../${REPO_NAME}-pre-purge-${TIMESTAMP}.tar.gz"

log_info "Creating tar backup of entire repo..."
tar -czf "${BACKUP_TAR}" -C "$(dirname "${REPO_PATH}")" "${REPO_NAME}"
BACKUP_TAR="$(realpath "${BACKUP_TAR}")"
BACKUP_SIZE="$(du -sh "${BACKUP_TAR}" | cut -f1)"
log_success "Tar backup created: ${BACKUP_TAR} (${BACKUP_SIZE})"

# Save remotes before git-filter-repo removes them
declare -A REMOTES
while IFS= read -r line; do
    name=$(echo "$line" | awk '{print $1}')
    url=$(echo "$line" | awk '{print $2}')
    type=$(echo "$line" | awk '{print $3}')
    if [[ "$type" == "(push)" ]]; then
        REMOTES["$name"]="$url"
    fi
done < <(git remote -v)

log_info "Saved ${#REMOTES[@]} remote(s):"
for name in "${!REMOTES[@]}"; do
    echo "  ${name} → ${REMOTES[$name]}"
done

# =============================================================================
# Create blob callback
# =============================================================================

log_header "Rewriting History with git-filter-repo"

# Write the blob callback to a file so git-filter-repo can source it.
# The callback runs once per blob with 'blob' in scope.
# We use a flat script (no function wrapper) — git-filter-repo executes
# the code block for every blob, but module-level imports and re.compile
# are cached by Python after the first exec.
CALLBACK_FILE=$(mktemp /tmp/shai-hulud-blob-callback-XXXXXX.py)

cat > "$CALLBACK_FILE" << 'PYTHON_CALLBACK'
import re, sys
_P = re.compile(rb'(\S)[ \t]{50,}(?:eval\(|global\[)')
if b'eval(' in blob.data or b'global[' in blob.data:
    lines = blob.data.split(b'\n')
    changed = False
    for i, line in enumerate(lines):
        m = _P.search(line)
        if m:
            lines[i] = line[:m.start() + 1]
            changed = True
    if changed:
        blob.data = b'\n'.join(lines)
        sys.stderr.write('Cleaned blob %s\n' % (blob.original_id or b'unknown').decode())
PYTHON_CALLBACK

log_info "Blob callback written to ${CALLBACK_FILE}"
log_info "Running git-filter-repo --blob-callback..."

cd "${REPO_PATH}"
git-filter-repo --blob-callback "$(cat "$CALLBACK_FILE")" --force 2>&1

FILTER_EXIT=$?

rm -f "$CALLBACK_FILE"

if [[ $FILTER_EXIT -ne 0 ]]; then
    log_error "git-filter-repo failed with exit code ${FILTER_EXIT}"
    log_info "Restore from tar backup with:"
    log_info "  rm -rf ${REPO_PATH} && tar -xzf ${BACKUP_TAR} -C $(dirname "${REPO_PATH}")"
    if [[ "$STASHED" == true ]]; then
        git stash pop || true
    fi
    exit 1
fi

log_success "git-filter-repo completed successfully"

# =============================================================================
# Restore remotes
# =============================================================================

log_header "Restoring Remotes"

for name in "${!REMOTES[@]}"; do
    url="${REMOTES[$name]}"
    git remote add "$name" "$url" 2>/dev/null || git remote set-url "$name" "$url"
    log_success "Restored remote: ${name} → ${url}"
done

# =============================================================================
# Verify
# =============================================================================

log_header "Verification"

# Check that the infected blobs are gone
log_info "Scanning rewritten history for malware..."
STILL_INFECTED=false

for pattern in "${MALWARE_PATTERNS[@]}"; do
    while IFS= read -r commit; do
        git diff-tree --no-commit-id -r "$commit" 2>/dev/null | while read -r mode1 mode2 hash1 hash2 status filepath; do
            if [[ "$status" != "D" ]] && git show "${commit}:${filepath}" 2>/dev/null | grep -qE "$pattern" 2>/dev/null; then
                log_error "Still infected: ${commit}:${filepath}"
                STILL_INFECTED=true
            fi
        done
    done < <(git log --all --format="%H")
done

if [[ "$STILL_INFECTED" == true ]]; then
    log_error "Malware still found in history! Something went wrong."
    log_info "Your backup is at ${BACKUP_TAR}"
    exit 1
fi

log_success "No malware found in rewritten history"

# Run the full scanner if available
if [[ "$HAS_SCANNER" == true ]]; then
    log_info "Running full Shai-Hulud scanner for final verification..."
    echo ""
    if "${SCANNER}" "${REPO_PATH}" --all-branches 2>&1; then
        log_success "Scanner confirms: repository is clean"
    else
        log_warn "Scanner reported findings — review output above"
    fi
fi

# Verify the working tree files are still correct
log_info "Verifying working tree files are unchanged..."
if git diff --quiet; then
    log_success "Working tree matches HEAD — no unintended changes"
else
    log_warn "Working tree has differences from HEAD — review with 'git diff'"
fi

# =============================================================================
# Force-push instructions
# =============================================================================

log_header "Next Steps: Force-Push"

echo ""
echo -e "  History has been rewritten locally. To update the remote repositories,"
echo -e "  you need to ${BOLD}force-push${NC} all branches to each remote."
echo ""
echo -e "  ${RED}WARNING:${NC} Force-pushing rewrites remote history. All collaborators"
echo -e "  will need to re-clone or rebase their local copies."
echo ""
echo -e "  Commands to run:"
echo ""

for name in "${!REMOTES[@]}"; do
    echo -e "    ${GREEN}git push --force-with-lease --all ${name}${NC}"
    echo -e "    ${GREEN}git push --force-with-lease --tags ${name}${NC}"
done

echo ""
echo -e "  Your backup is at: ${CYAN}${BACKUP_TAR}${NC}"
echo -e "  To restore if anything goes wrong:"
echo -e "    rm -rf ${REPO_PATH} && tar -xzf ${BACKUP_TAR} -C $(dirname "${REPO_PATH}")"
echo ""

read -rp "Force-push to all remotes now? (y/N): " push_confirm
if [[ "$push_confirm" == "y" || "$push_confirm" == "Y" ]]; then
    for name in "${!REMOTES[@]}"; do
        log_info "Pushing to ${name}..."
        if git push --force-with-lease --all "$name" 2>&1; then
            log_success "Pushed all branches to ${name}"
        else
            log_error "Failed to push to ${name}"
        fi
        if git push --force-with-lease --tags "$name" 2>&1; then
            log_success "Pushed all tags to ${name}"
        else
            log_warn "Failed to push tags to ${name} (may have no tags)"
        fi
    done
    echo ""
    log_success "All remotes updated!"
    echo ""
    echo -e "  ${YELLOW}IMPORTANT:${NC} Notify all collaborators to re-clone or run:"
    echo -e "    git fetch --all && git reset --hard origin/main"
else
    log_info "Skipped force-push. Run the commands above when ready."
fi

# Restore stashed changes if we stashed them
if [[ "$STASHED" == true ]]; then
    log_info "Restoring stashed changes..."
    git stash pop && log_success "Stashed changes restored" || log_warn "Could not restore stash — run 'git stash pop' manually"
fi

echo ""
log_success "Done! Malware has been purged from git history."
