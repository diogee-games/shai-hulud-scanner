#!/bin/bash
#
# Malware Detection & Cleanup Script for Config File Injection
# Based on incident reports: Shai-Hulud supply chain attack
#
# IOCs:
#   - Config files with abnormally large size (>5KB when typically <1KB)
#   - Lines longer than 256 characters (payload uses ~2000 spaces for obfuscation)
#   - Malware signatures: global.i='5-3-247', '5-3-267', '5-228', '5-3-238', '5-143'
#   - Known payload files: setup_bun.js, bun_environment.js, set_bun.js, bundle.js
#   - Known SHA256 hashes of Shai-Hulud payloads
#   - Suspicious package.json preinstall/postinstall scripts
#   - Behavioral indicators: TruffleHog, GitHub runner registration, webhook exfiltration
#   - Abnormally large JS files (>5MB, Shai-Hulud payloads can be 9MB+)
#
# Usage:
#   ./detect-config-malware.sh /path/to/repo [--verbose]
#   ./detect-config-malware.sh /path/to/repo --all-branches
#   ./detect-config-malware.sh /path/to/repo --cleanup
#
# Modes:
#   (default)   Detection only — scans current branch, reports findings, changes nothing
#   --cleanup   Interactive cleanup — finds infected files, restores from clean git history
#
# ╔══════════════════════════════════════════════════════════════╗
# ║  WARNING: --cleanup REWRITES GIT HISTORY                    ║
# ║                                                              ║
# ║  Cleanup mode will:                                          ║
# ║    1. Find infected files on the current branch              ║
# ║    2. Search git history for the last clean version           ║
# ║    3. Restore the clean version to the working tree           ║
# ║    4. Create a commit with the fix                            ║
# ║    5. Prompt you to force-push (REWRITES REMOTE HISTORY)     ║
# ║                                                              ║
# ║  Force-pushing overwrites the remote branch. All developers  ║
# ║  MUST re-pull after cleanup. Commits made on top of infected ║
# ║  history may be lost. Coordinate with your team first.       ║
# ╚══════════════════════════════════════════════════════════════╝
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
MAX_LINE_LENGTH=256
MIN_SUSPICIOUS_FILE_SIZE=8000  # 8KB - flag very large configs

VERBOSE=false
ALL_BRANCHES=false
CURRENT_BRANCH_ONLY=true
CLEANUP_MODE=false
ISSUES_FOUND=0
FILES_SCANNED=0
INFECTED_FILES=()  # Track infected files for cleanup

# Known Shai-Hulud malware strain IDs
MALWARE_STRAINS=("5-3-247" "5-3-267" "5-228" "5-3-238" "5-143")

# Known payload filenames
KNOWN_PAYLOAD_FILES=("setup_bun.js" "bun_environment.js" "set_bun.js" "bundle.js")

# Known payload SHA256 hashes
KNOWN_HASHES=(
    "46faab8ab153fae6e80e7cca38eab363075bb524edd79e42269217a083628f09"  # bundle.js
    "62ee164b9b306250c1172583f138c9614139264f889fa99614903c12755468d0"  # bun_environment.js v1
    "f099c5d9ec417d4445a0328ac0ada9cde79fc37410914103ae9c609cbc0ee068"  # bun_environment.js v2
    "cbb9bc5a8496243e02f3cc080efbe3e4a1430ba0671f2e43a202bf45b05479cd"  # bun_environment.js v3
    "a3894003ad1d293ba96d77881ccd2071446dc3f65f434669b49b3da92421901a"  # setup_bun.js
)

# Suspicious patterns in package.json scripts
PACKAGE_JSON_PATTERNS=(
    "setup_bun"
    "set_bun"
    "bun_environment"
    "bun\.sh/install"
    "curl.*bun\.sh"
)

# Obfuscation patterns (eval+atob, large base64 blobs)
OBFUSCATION_PATTERNS=(
    "eval\(.*atob\("               # eval(..atob(..) — base64-decoded code execution
    "eval\(.*global\["             # eval(..global[.. — obfuscated global access
    "global\[['\"]_V['\"]\]"       # global['_V'] — variant strain marker
    "global\[['\"]r['\"]\]=require" # global['r']=require — require hijacking
)

# Behavioral indicators in any file
BEHAVIORAL_PATTERNS=(
    "trufflehog filesystem"
    "SHA1HULUD"
    "SHA1Hulud"
    "Shai-Hulud"
    "Sha1-Hulud"
    "webhook\.site"
    "actions/runner/releases/download"
    "Runner\.Listener"
    "--name SHA1"
    "az account get-access-token"
    "azd auth token"
)

# Large JS file threshold (Shai-Hulud payloads can be 9MB+)
LARGE_JS_THRESHOLD=5000000  # 5MB

# Config file patterns for git grep/ls-tree matching
CONFIG_PATTERNS=(
    "*.config.js"
    "*.config.ts"
    "*.config.mjs"
    "*.config.cjs"
    "tailwind.config.*"
    "postcss.config.*"
    "vite.config.*"
    "webpack.config.*"
    "rollup.config.*"
    "babel.config.*"
    "jest.config.*"
    "vitest.config.*"
    "eslint.config.*"
    "prettier.config.*"
    "next.config.*"
    "nuxt.config.*"
    ".eslintrc.js"
    ".prettierrc.js"
    ".babelrc.js"
)

# Directories to exclude
EXCLUDE_DIRS=("node_modules" ".git" "vendor" ".pnpm" "dist" "build")

print_header() {
    echo -e "${BLUE}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║     Config File Malware Detection Script (Shai-Hulud)        ║${NC}"
    if [[ "$CLEANUP_MODE" == true ]]; then
        echo -e "${RED}║              Mode: CLEANUP (rewrites history)                 ║${NC}"
    elif [[ "$CURRENT_BRANCH_ONLY" == true ]]; then
        echo -e "${BLUE}║              Mode: Current Branch Only                        ║${NC}"
    elif [[ "$ALL_BRANCHES" == true ]]; then
        echo -e "${BLUE}║              Mode: All Branches                              ║${NC}"
    fi
    echo -e "${BLUE}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
}

print_usage() {
    echo "Usage: $0 <repo-path> [--all-branches] [--cleanup] [--verbose]"
    echo ""
    echo "Modes:"
    echo "  (default)          Detection only — scan current branch (7-phase)"
    echo "  --all-branches     Scan all local and remote branches (7-phase)"
    echo "  --cleanup          Interactive cleanup — restore infected files from clean history"
    echo ""
    echo "Options:"
    echo "  --verbose          Show detailed output including all files scanned"
    echo ""
    echo "Examples:"
    echo "  $0 /path/to/repo                      # Scan current branch"
    echo "  $0 /path/to/repo --all-branches        # Scan all branches"
    echo "  $0 /path/to/repo --cleanup              # Find and fix infected files"
    echo ""
    echo -e "${RED}WARNING: --cleanup REWRITES GIT HISTORY. Force-push required after cleanup.${NC}"
    echo "         All developers must re-pull after cleanup. Coordinate with your team."
}

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_verbose() {
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${BLUE}[INFO]${NC} $1"
    fi
}

log_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
    ((ISSUES_FOUND++)) || true
}

log_critical() {
    echo -e "${RED}[CRITICAL]${NC} $1"
    ((ISSUES_FOUND++)) || true
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

# ─────────────────────────────────────────────────────────────
# Working-tree checks (original behavior)
# ─────────────────────────────────────────────────────────────

check_malware_signature() {
    local file="$1"
    local found=false

    for strain in "${MALWARE_STRAINS[@]}"; do
        if grep -qE "global\.i=['\"]${strain}['\"]" "$file" 2>/dev/null; then
            log_critical "MALWARE SIGNATURE DETECTED in $file"
            log_critical "  └─ Pattern: global.i='${strain}'"
            found=true
        fi
    done

    # Generic global.i pattern (catches new strains)
    if grep -qE "global\.i=['\"][0-9]+-[0-9]+(-[0-9]+)?['\"]" "$file" 2>/dev/null; then
        local sig
        sig=$(grep -oE "global\.i=['\"][0-9]+-[0-9]+(-[0-9]+)?['\"]" "$file" 2>/dev/null | head -1)
        if [[ "$found" == false ]]; then
            log_critical "UNKNOWN MALWARE STRAIN DETECTED in $file"
            log_critical "  └─ Pattern: ${sig}"
            found=true
        fi
    fi

    # Obfuscation patterns (eval+atob, global['_V'], require hijacking)
    for pattern in "${OBFUSCATION_PATTERNS[@]}"; do
        if grep -qE "$pattern" "$file" 2>/dev/null; then
            local matched
            matched=$(grep -oE "$pattern" "$file" 2>/dev/null | head -1)
            log_critical "OBFUSCATED MALWARE DETECTED in $file"
            log_critical "  └─ Pattern: ${matched}"
            found=true
        fi
    done

    # Large base64 blobs (200+ chars) — payload delivery mechanism
    if grep -qE '[A-Za-z0-9+/]{200,}={0,2}' "$file" 2>/dev/null; then
        log_critical "LARGE BASE64 BLOB in $file"
        log_critical "  └─ Possible encoded malware payload"
        found=true
    fi

    [[ "$found" == true ]] && return 1
    return 0
}

check_long_lines() {
    local file="$1"
    local max_len="$MAX_LINE_LENGTH"

    local long_lines
    long_lines=$(awk -v max="$max_len" 'length > max {print NR": "length" chars"}' "$file" 2>/dev/null || true)

    if [[ -n "$long_lines" ]]; then
        log_warning "Long lines detected in $file (>$max_len chars):"
        echo "$long_lines" | head -5 | while read -r line; do
            echo "    └─ Line $line"
        done

        if awk -v max="$max_len" 'length > max' "$file" 2>/dev/null | grep -qE '[[:space:]]{100,}'; then
            log_critical "  └─ Contains suspicious whitespace padding (potential obfuscation)"
        fi
        return 1
    fi
    return 0
}

check_file_size() {
    local file="$1"
    local size

    size=$(stat -c%s "$file" 2>/dev/null) || size=$(stat -f%z "$file" 2>/dev/null) || size=0

    if [[ "$size" -gt "$MIN_SUSPICIOUS_FILE_SIZE" ]]; then
        log_warning "Large config file: $file ($size bytes)"
        log_warning "  └─ Normal config files are typically <1KB"
        return 1
    fi
    return 0
}

check_hidden_content() {
    local file="$1"

    if grep -qE '[^[:space:]][[:space:]]{50,}[^[:space:]]' "$file" 2>/dev/null; then
        log_warning "Potential hidden content in $file"
        log_warning "  └─ Found text separated by 50+ spaces on same line"

        grep -nE '[^[:space:]][[:space:]]{50,}[^[:space:]]' "$file" 2>/dev/null | head -3 | while read -r line; do
            local linenum="${line%%:*}"
            echo "    └─ Line $linenum has hidden content after whitespace"
        done
        return 1
    fi
    return 0
}

check_repo_visibility() {
    local repo_path="$1"

    if [[ ! -d "$repo_path/.git" ]]; then
        return 0
    fi

    local remote_url
    remote_url=$(git -C "$repo_path" remote get-url origin 2>/dev/null || true)

    if [[ -z "$remote_url" ]]; then
        return 0
    fi

    local repo_slug
    if [[ "$remote_url" =~ github\.com[:/]([^/]+/[^/.]+) ]]; then
        repo_slug="${BASH_REMATCH[1]}"
        repo_slug="${repo_slug%.git}"

        if command -v gh &>/dev/null; then
            local visibility
            visibility=$(gh repo view "$repo_slug" --json visibility -q '.visibility' 2>/dev/null || true)

            if [[ "$visibility" == "PUBLIC" ]]; then
                log_info "Repository is PUBLIC: $repo_slug"
                log_info "  └─ URL: https://github.com/$repo_slug"
            elif [[ -n "$visibility" ]]; then
                log_info "Repository is $visibility: $repo_slug"
            fi
        fi
    fi
}

scan_file() {
    local file="$1"
    local has_issues=false

    ((FILES_SCANNED++)) || true
    log_verbose "Scanning: $file"

    check_malware_signature "$file" || has_issues=true
    check_file_size "$file" || has_issues=true
    check_long_lines "$file" || has_issues=true
    check_hidden_content "$file" || has_issues=true

    if [[ "$has_issues" == false ]]; then
        log_verbose "  └─ Clean"
    fi
}

# Working-tree scan (original behavior)
scan_repo_worktree() {
    local repo_path="$1"

    echo -e "${BLUE}Scanning repository (working tree):${NC} $repo_path"
    echo ""

    check_repo_visibility "$repo_path"
    echo ""

    # Find config files, excluding unwanted dirs
    while IFS= read -r file; do
        [[ -n "$file" ]] && scan_file "$file"
    done < <(find "$repo_path" -type f \( \
        -name "*.config.js" -o \
        -name "*.config.ts" -o \
        -name "*.config.mjs" -o \
        -name "*.config.cjs" -o \
        -name "tailwind.config.*" -o \
        -name "postcss.config.*" -o \
        -name "vite.config.*" -o \
        -name "webpack.config.*" -o \
        -name "rollup.config.*" -o \
        -name "babel.config.*" -o \
        -name "jest.config.*" -o \
        -name "vitest.config.*" -o \
        -name "eslint.config.*" -o \
        -name "prettier.config.*" -o \
        -name "next.config.*" -o \
        -name "nuxt.config.*" -o \
        -name ".eslintrc.js" -o \
        -name ".prettierrc.js" -o \
        -name ".babelrc.js" \
        \) \
        ! -path "*/node_modules/*" \
        ! -path "*/.git/*" \
        ! -path "*/vendor/*" \
        ! -path "*/.pnpm/*" \
        ! -path "*/dist/*" \
        ! -path "*/build/*" \
        2>/dev/null)

    # Scan all JS/TS files for malware signatures
    echo ""
    echo -e "${BLUE}Scanning all JS/TS files for malware signatures...${NC}"

    local sig_found=false

    # Pattern 1: Direct global.i strain markers
    local sig_matches
    sig_matches=$(grep -rlE "global\.i=['\"][0-9]+-[0-9]+(-[0-9]+)?['\"]" "$repo_path" \
        --include="*.js" --include="*.ts" --include="*.mjs" --include="*.cjs" \
        --exclude-dir=node_modules --exclude-dir=.git --exclude-dir=vendor --exclude-dir=dist --exclude-dir=build \
        2>/dev/null || true)

    if [[ -n "$sig_matches" ]]; then
        sig_found=true
        while read -r file; do
            if [[ -n "$file" ]]; then
                local strain
                strain=$(grep -oE "global\.i=['\"][0-9]+-[0-9]+(-[0-9]+)?['\"]" "$file" 2>/dev/null | head -1)
                log_critical "MALWARE SIGNATURE FOUND IN: $file"
                log_critical "  └─ Strain: ${strain}"
            fi
        done <<< "$sig_matches"
    fi

    # Pattern 2: eval+atob obfuscation (base64-encoded payloads)
    local obf_matches
    obf_matches=$(grep -rlE "eval\(.*atob\(" "$repo_path" \
        --include="*.js" --include="*.ts" --include="*.mjs" --include="*.cjs" \
        --exclude-dir=node_modules --exclude-dir=.git --exclude-dir=vendor --exclude-dir=dist --exclude-dir=build \
        2>/dev/null || true)

    if [[ -n "$obf_matches" ]]; then
        sig_found=true
        while read -r file; do
            [[ -z "$file" ]] && continue
            log_critical "OBFUSCATED MALWARE (eval+atob) FOUND IN: $file"
        done <<< "$obf_matches"
    fi

    # Pattern 3: global['_V'] variant strain marker
    local gv_matches
    gv_matches=$(grep -rlE "global\[['\"]_V['\"]\]" "$repo_path" \
        --include="*.js" --include="*.ts" --include="*.mjs" --include="*.cjs" \
        --exclude-dir=node_modules --exclude-dir=.git --exclude-dir=vendor --exclude-dir=dist --exclude-dir=build \
        2>/dev/null || true)

    if [[ -n "$gv_matches" ]]; then
        sig_found=true
        while read -r file; do
            [[ -z "$file" ]] && continue
            log_critical "MALWARE VARIANT (global['_V']) FOUND IN: $file"
        done <<< "$gv_matches"
    fi

    if [[ "$sig_found" == false ]]; then
        echo "  No malware signatures found."
    fi
}

# ─────────────────────────────────────────────────────────────
# All-branches scanning (git object store)
# ─────────────────────────────────────────────────────────────

# Get all unique branch refs (local + remote, deduped)
get_all_refs() {
    local repo_path="$1"

    git -C "$repo_path" for-each-ref --format='%(refname)' refs/heads/ refs/remotes/ 2>/dev/null \
        | grep -v '/HEAD$' \
        | sort -u
}

# Scan all branches for malware signatures using git grep
scan_branches_signatures() {
    local repo_path="$1"
    shift
    local refs=("$@")

    echo -e "${BLUE}Scanning all branches for malware signatures...${NC}"

    local found_any=false

    # Patterns to scan for across all branches
    local patterns=(
        "global\.i=['\"][0-9]+-[0-9]+(-[0-9]+)?['\"]"   # direct strain marker
        "eval\(.*atob\("                                  # eval+atob obfuscation
        "global\[['\"]_V['\"]\]"                          # variant strain marker
        "global\[['\"]r['\"]\]=require"                   # require hijacking
    )
    local pattern_labels=(
        "MALWARE SIGNATURE"
        "OBFUSCATED MALWARE (eval+atob)"
        "MALWARE VARIANT (global['_V'])"
        "REQUIRE HIJACKING (global['r']=require)"
    )

    for p_idx in "${!patterns[@]}"; do
        local pattern="${patterns[$p_idx]}"
        local label="${pattern_labels[$p_idx]}"

        local batch_size=50
        local i=0
        local batch=()

        for ref in "${refs[@]}"; do
            batch+=("$ref")
            ((i++)) || true

            if [[ $i -ge $batch_size ]] || [[ "$ref" == "${refs[-1]}" ]]; then
                local results
                results=$(git -C "$repo_path" grep -lE "$pattern" "${batch[@]}" -- \
                    '*.js' '*.ts' '*.mjs' '*.cjs' \
                    '*.config.js' '*.config.ts' '*.config.mjs' '*.config.cjs' \
                    2>/dev/null || true)

                if [[ -n "$results" ]]; then
                    found_any=true
                    while IFS= read -r match; do
                        [[ -z "$match" ]] && continue
                        local match_ref="${match%%:*}"
                        local match_path="${match#*:}"

                        log_critical "${label} in ${CYAN}${match_ref}${NC}:${match_path}"
                    done <<< "$results"
                fi

                batch=()
                i=0
            fi
        done
    done

    if [[ "$found_any" == false ]]; then
        echo "  No malware signatures found across any branch."
    fi
}

# Scan all branches for whitespace obfuscation in any JS/TS file
scan_branches_whitespace_obfuscation() {
    local repo_path="$1"
    shift
    local refs=("$@")

    echo ""
    echo -e "${BLUE}Scanning all branches for whitespace obfuscation in JS/TS files...${NC}"

    local found_any=false
    # Pattern: text, then 50+ spaces, then more text on the same line (hidden payload)
    local obfuscation_pattern='[^[:space:]][[:space:]]{50,}[^[:space:]]'

    local batch_size=50
    local i=0
    local batch=()

    for ref in "${refs[@]}"; do
        batch+=("$ref")
        ((i++)) || true

        if [[ $i -ge $batch_size ]] || [[ "$ref" == "${refs[-1]}" ]]; then
            local results
            results=$(git -C "$repo_path" grep -lE "$obfuscation_pattern" "${batch[@]}" -- \
                '*.js' '*.mjs' '*.cjs' '*.ts' '*.mts' '*.cts' \
                ':!node_modules' ':!vendor' ':!dist' ':!build' ':!*.min.js' ':!*.bundle.js' \
                2>/dev/null || true)

            if [[ -n "$results" ]]; then
                while IFS= read -r match; do
                    [[ -z "$match" ]] && continue
                    local match_ref="${match%%:*}"
                    local match_path="${match#*:}"
                    local ref_short="${match_ref#refs/remotes/}"
                    ref_short="${ref_short#refs/heads/}"

                    # Skip known minified/bundled paths
                    [[ "$match_path" == *"node_modules"* ]] && continue
                    [[ "$match_path" == *"vendor"* ]] && continue
                    [[ "$match_path" == *"dist/"* ]] && continue
                    [[ "$match_path" == *"build/"* ]] && continue
                    [[ "$match_path" == *".min.js" ]] && continue
                    [[ "$match_path" == *".bundle.js" ]] && continue

                    found_any=true
                    log_critical "WHITESPACE OBFUSCATION in ${CYAN}${ref_short}${NC}:${match_path}"
                    log_critical "  └─ Hidden content detected (50+ spaces separating code)"
                done <<< "$results"
            fi

            batch=()
            i=0
        fi
    done

    if [[ "$found_any" == false ]]; then
        echo "  No whitespace obfuscation found in JS/TS files."
    fi
}

# Build a grep pattern to match config file names in ls-tree output
CONFIG_FILE_GREP_PATTERN='\.config\.(js|ts|mjs|cjs)$|tailwind\.config\.|postcss\.config\.|vite\.config\.|webpack\.config\.|rollup\.config\.|babel\.config\.|jest\.config\.|vitest\.config\.|eslint\.config\.|prettier\.config\.|next\.config\.|nuxt\.config\.|\.eslintrc\.js$|\.prettierrc\.js$|\.babelrc\.js$'

# Pattern to exclude directories (used by awk, so no backslash escapes needed)
EXCLUDE_DIR_PATTERN='(^|/)node_modules/|[.]git/|vendor/|[.]pnpm/|dist/|build/'

# Scan all branches for large config files and suspicious content
scan_branches_config_files() {
    local repo_path="$1"
    shift
    local refs=("$@")

    echo ""
    echo -e "${BLUE}Scanning all branches for suspicious config files...${NC}"

    local found_any=false

    for ref in "${refs[@]}"; do
        local ref_short="${ref#refs/remotes/}"
        ref_short="${ref_short#refs/heads/}"

        # Pre-filter: only config files, exclude unwanted dirs
        while IFS=$'\t' read -r meta path; do
            [[ -z "$path" ]] && continue

            # Parse size from meta: "mode type hash size"
            local size
            size=$(echo "$meta" | awk '{print $4}')
            [[ -z "$size" || "$size" == "-" ]] && continue

            ((FILES_SCANNED++)) || true

            # Check size
            if [[ "$size" -gt "$MIN_SUSPICIOUS_FILE_SIZE" ]]; then
                found_any=true
                log_warning "Large config file: ${CYAN}${ref_short}${NC}:${path} (${size} bytes)"
            fi

            # Only fetch content for detailed checks if file is large enough to matter
            # or in verbose mode. Small files (<1KB) are unlikely to contain hidden payloads.
            if [[ "$size" -gt 1000 ]] || [[ "$VERBOSE" == true ]]; then
                local content
                content=$(git -C "$repo_path" show "${ref}:${path}" 2>/dev/null || true)
                [[ -z "$content" ]] && continue

                # Check for long lines
                local long_lines
                long_lines=$(echo "$content" | awk -v max="$MAX_LINE_LENGTH" 'length > max {print NR": "length" chars"}' 2>/dev/null || true)
                if [[ -n "$long_lines" ]]; then
                    found_any=true
                    log_warning "Long lines in ${CYAN}${ref_short}${NC}:${path} (>$MAX_LINE_LENGTH chars):"
                    echo "$long_lines" | head -3 | while read -r line; do
                        echo "    └─ Line $line"
                    done

                    # Check for suspicious whitespace padding
                    if echo "$content" | awk -v max="$MAX_LINE_LENGTH" 'length > max' 2>/dev/null | grep -qE '[[:space:]]{100,}'; then
                        log_critical "  └─ Contains suspicious whitespace padding (potential obfuscation)"
                    fi
                fi

                # Check for hidden content
                if echo "$content" | grep -qE '[^[:space:]][[:space:]]{50,}[^[:space:]]' 2>/dev/null; then
                    found_any=true
                    log_warning "Potential hidden content in ${CYAN}${ref_short}${NC}:${path}"
                    log_warning "  └─ Found text separated by 50+ spaces on same line"
                fi
            fi

            log_verbose "  Clean: ${ref_short}:${path}"

        done < <(git -C "$repo_path" ls-tree -l -r "$ref" 2>/dev/null \
            | grep -E "$CONFIG_FILE_GREP_PATTERN" \
            | awk -v pat="$EXCLUDE_DIR_PATTERN" '$0 !~ pat' \
            || true)
    done

    if [[ "$found_any" == false ]]; then
        echo "  No suspicious config files found across any branch."
    fi
}

# Current-branch-only scan (7-phase, scoped to HEAD)
scan_repo_current_branch() {
    local repo_path="$1"

    # Verify it's a git repo
    if [[ ! -d "$repo_path/.git" ]]; then
        echo -e "${RED}[ERROR]${NC} Not a git repository: $repo_path"
        return 1
    fi

    local current_branch
    current_branch=$(git -C "$repo_path" branch --show-current 2>/dev/null || echo "")

    if [[ -z "$current_branch" ]]; then
        log_warning "Detached HEAD — using HEAD directly"
        current_branch="HEAD"
    fi

    echo -e "${BLUE}Scanning repository (current branch):${NC} $repo_path"
    echo -e "  Branch: ${CYAN}${current_branch}${NC}"
    echo ""

    check_repo_visibility "$repo_path"
    echo ""

    # Resolve to a ref that git grep/ls-tree can use
    local ref
    if [[ "$current_branch" == "HEAD" ]]; then
        ref="HEAD"
    else
        ref="refs/heads/${current_branch}"
    fi

    local refs_array=("$ref")

    # Run all 7 phases against the single ref
    scan_branches_signatures "$repo_path" "${refs_array[@]}"
    scan_branches_whitespace_obfuscation "$repo_path" "${refs_array[@]}"
    scan_branches_config_files "$repo_path" "${refs_array[@]}"
    scan_branches_known_payloads "$repo_path" "${refs_array[@]}"
    scan_branches_package_json "$repo_path" "${refs_array[@]}"
    scan_branches_behavioral "$repo_path" "${refs_array[@]}"
    scan_branches_large_js "$repo_path" "${refs_array[@]}"
}

# Main all-branches scan
scan_repo_all_branches() {
    local repo_path="$1"

    echo -e "${BLUE}Scanning repository (all branches):${NC} $repo_path"
    echo ""

    # Check visibility
    check_repo_visibility "$repo_path"
    echo ""

    # Verify it's a git repo
    if [[ ! -d "$repo_path/.git" ]]; then
        echo -e "${RED}[ERROR]${NC} Not a git repository: $repo_path"
        return 1
    fi

    # Fetch all remote branches
    echo -e "${BLUE}Fetching remote branches...${NC}"
    git -C "$repo_path" fetch --all --quiet 2>/dev/null || {
        echo -e "${YELLOW}[WARN]${NC} Failed to fetch remotes (may be offline), scanning available refs"
    }

    # Get all refs
    local refs_array=()
    while IFS= read -r ref; do
        [[ -n "$ref" ]] && refs_array+=("$ref")
    done < <(get_all_refs "$repo_path")

    local ref_count=${#refs_array[@]}
    echo -e "  Found ${CYAN}${ref_count}${NC} branch refs to scan"
    echo ""

    if [[ $ref_count -eq 0 ]]; then
        log_warning "No branches found, falling back to working-tree scan"
        scan_repo_worktree "$repo_path"
        return
    fi

    # Show branch list in verbose mode
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${BLUE}Branches:${NC}"
        for ref in "${refs_array[@]}"; do
            local short="${ref#refs/remotes/}"
            short="${short#refs/heads/}"
            echo "    $short"
        done
        echo ""
    fi

    # Phase 1: Malware signature scan across all JS/TS files on all branches
    scan_branches_signatures "$repo_path" "${refs_array[@]}"

    # Phase 2: Whitespace obfuscation scan across all JS/TS files on all branches
    scan_branches_whitespace_obfuscation "$repo_path" "${refs_array[@]}"

    # Phase 3: Config file size/content analysis across all branches
    scan_branches_config_files "$repo_path" "${refs_array[@]}"

    # Phase 4: Known Shai-Hulud payload files and hashes
    scan_branches_known_payloads "$repo_path" "${refs_array[@]}"

    # Phase 5: Suspicious package.json scripts (preinstall/postinstall)
    scan_branches_package_json "$repo_path" "${refs_array[@]}"

    # Phase 6: Behavioral indicators (TruffleHog, runner registration, exfiltration)
    scan_branches_behavioral "$repo_path" "${refs_array[@]}"

    # Phase 7: Abnormally large JS files (>5MB, potential payloads)
    scan_branches_large_js "$repo_path" "${refs_array[@]}"
}

# Scan all branches for known Shai-Hulud payload filenames and SHA256 hashes
scan_branches_known_payloads() {
    local repo_path="$1"
    shift
    local refs=("$@")

    echo ""
    echo -e "${BLUE}Scanning all branches for known Shai-Hulud payload files...${NC}"

    local found_any=false

    for ref in "${refs[@]}"; do
        local ref_short="${ref#refs/remotes/}"
        ref_short="${ref_short#refs/heads/}"

        # Check for known payload filenames
        for payload_name in "${KNOWN_PAYLOAD_FILES[@]}"; do
            local matches
            matches=$(git -C "$repo_path" ls-tree -r --name-only "$ref" 2>/dev/null \
                | grep -E "(^|/)${payload_name}$" || true)

            if [[ -n "$matches" ]]; then
                while IFS= read -r match_path; do
                    [[ -z "$match_path" ]] && continue
                    [[ "$match_path" == *"node_modules"* ]] && continue

                    found_any=true
                    log_critical "KNOWN PAYLOAD FILE in ${CYAN}${ref_short}${NC}:${match_path}"

                    # Check SHA256 hash against known hashes
                    local file_hash
                    file_hash=$(git -C "$repo_path" show "${ref}:${match_path}" 2>/dev/null | sha256sum | awk '{print $1}')

                    local hash_matched=false
                    for known_hash in "${KNOWN_HASHES[@]}"; do
                        if [[ "$file_hash" == "$known_hash" ]]; then
                            log_critical "  └─ SHA256 MATCH: ${file_hash} (confirmed Shai-Hulud payload)"
                            hash_matched=true
                            break
                        fi
                    done

                    if [[ "$hash_matched" == false ]]; then
                        log_warning "  └─ SHA256: ${file_hash} (filename match, hash not in known list)"
                    fi
                done <<< "$matches"
            fi
        done
    done

    if [[ "$found_any" == false ]]; then
        echo "  No known payload files found across any branch."
    fi
}

# Scan all branches for suspicious package.json preinstall/postinstall scripts
scan_branches_package_json() {
    local repo_path="$1"
    shift
    local refs=("$@")

    echo ""
    echo -e "${BLUE}Scanning all branches for suspicious package.json scripts...${NC}"

    local found_any=false

    for ref in "${refs[@]}"; do
        local ref_short="${ref#refs/remotes/}"
        ref_short="${ref_short#refs/heads/}"

        # Find all package.json files in this ref
        local pkg_files
        pkg_files=$(git -C "$repo_path" ls-tree -r --name-only "$ref" 2>/dev/null \
            | grep -E '(^|/)package\.json$' \
            | grep -vE '(^|/)node_modules/' || true)

        [[ -z "$pkg_files" ]] && continue

        while IFS= read -r pkg_path; do
            [[ -z "$pkg_path" ]] && continue

            local content
            content=$(git -C "$repo_path" show "${ref}:${pkg_path}" 2>/dev/null || true)
            [[ -z "$content" ]] && continue

            # Check for suspicious patterns in preinstall/postinstall/prepare scripts
            local scripts_section
            scripts_section=$(echo "$content" | python3 -c "
import sys, json
try:
    pkg = json.load(sys.stdin)
    scripts = pkg.get('scripts', {})
    for key in ['preinstall', 'postinstall', 'prepare', 'prepublish', 'prepack']:
        if key in scripts:
            print(f'{key}: {scripts[key]}')
except: pass
" 2>/dev/null || true)

            [[ -z "$scripts_section" ]] && continue

            for pattern in "${PACKAGE_JSON_PATTERNS[@]}"; do
                if echo "$scripts_section" | grep -qE "$pattern" 2>/dev/null; then
                    found_any=true
                    local matched_line
                    matched_line=$(echo "$scripts_section" | grep -E "$pattern" | head -1)
                    log_critical "SUSPICIOUS SCRIPT in ${CYAN}${ref_short}${NC}:${pkg_path}"
                    log_critical "  └─ ${matched_line}"
                fi
            done

            # Also flag any preinstall/postinstall that runs node on a JS file
            if echo "$scripts_section" | grep -qE '(preinstall|postinstall):.*node\s+' 2>/dev/null; then
                local matched_line
                matched_line=$(echo "$scripts_section" | grep -E '(preinstall|postinstall):.*node\s+' | head -1)
                found_any=true
                log_warning "LIFECYCLE SCRIPT runs node in ${CYAN}${ref_short}${NC}:${pkg_path}"
                log_warning "  └─ ${matched_line}"
            fi
        done <<< "$pkg_files"
    done

    if [[ "$found_any" == false ]]; then
        echo "  No suspicious package.json scripts found across any branch."
    fi
}

# Scan all branches for behavioral indicators of Shai-Hulud
scan_branches_behavioral() {
    local repo_path="$1"
    shift
    local refs=("$@")

    echo ""
    echo -e "${BLUE}Scanning all branches for Shai-Hulud behavioral indicators...${NC}"

    local found_any=false

    # Build combined regex from behavioral patterns
    local combined_pattern=""
    for pattern in "${BEHAVIORAL_PATTERNS[@]}"; do
        if [[ -n "$combined_pattern" ]]; then
            combined_pattern="${combined_pattern}|${pattern}"
        else
            combined_pattern="$pattern"
        fi
    done

    local batch_size=50
    local i=0
    local batch=()

    for ref in "${refs[@]}"; do
        batch+=("$ref")
        ((i++)) || true

        if [[ $i -ge $batch_size ]] || [[ "$ref" == "${refs[-1]}" ]]; then
            local results
            results=$(git -C "$repo_path" grep -lE "$combined_pattern" "${batch[@]}" -- \
                '*.js' '*.ts' '*.mjs' '*.cjs' '*.sh' '*.yml' '*.yaml' '*.json' \
                ':!node_modules' ':!vendor' ':!dist' ':!build' \
                2>/dev/null || true)

            if [[ -n "$results" ]]; then
                while IFS= read -r match; do
                    [[ -z "$match" ]] && continue
                    local match_ref="${match%%:*}"
                    local match_path="${match#*:}"
                    local ref_short="${match_ref#refs/remotes/}"
                    ref_short="${ref_short#refs/heads/}"

                    [[ "$match_path" == *"node_modules"* ]] && continue
                    [[ "$match_path" == *"vendor"* ]] && continue

                    # Skip scanner files, blog/documentation, and session logs
                    [[ "$match_path" == *"detect-config-malware"* ]] && continue
                    [[ "$match_path" == *"scan-all-repos"* ]] && continue
                    [[ "$match_path" == *"shai-hulud-scanner"* ]] && continue
                    [[ "$match_path" == *"content/blog"* ]] && continue
                    [[ "$match_path" == *"logs/conversations"* ]] && continue
                    [[ "$match_path" == *".md" ]] && continue

                    found_any=true

                    # Identify which pattern matched
                    local matched_patterns=""
                    local file_content
                    file_content=$(git -C "$repo_path" show "${match_ref}:${match_path}" 2>/dev/null || true)
                    for pattern in "${BEHAVIORAL_PATTERNS[@]}"; do
                        if echo "$file_content" | grep -qE "$pattern" 2>/dev/null; then
                            matched_patterns="${matched_patterns} [${pattern}]"
                        fi
                    done

                    log_critical "BEHAVIORAL INDICATOR in ${CYAN}${ref_short}${NC}:${match_path}"
                    log_critical "  └─ Matched:${matched_patterns}"
                done <<< "$results"
            fi

            batch=()
            i=0
        fi
    done

    if [[ "$found_any" == false ]]; then
        echo "  No behavioral indicators found across any branch."
    fi
}

# Scan all branches for abnormally large JS files (potential 9MB+ payloads)
scan_branches_large_js() {
    local repo_path="$1"
    shift
    local refs=("$@")

    echo ""
    echo -e "${BLUE}Scanning all branches for abnormally large JS files (>${LARGE_JS_THRESHOLD} bytes)...${NC}"

    local found_any=false

    for ref in "${refs[@]}"; do
        local ref_short="${ref#refs/remotes/}"
        ref_short="${ref_short#refs/heads/}"

        # ls-tree -l gives us file sizes in the git object store
        while IFS=$'\t' read -r meta path; do
            [[ -z "$path" ]] && continue

            local size
            size=$(echo "$meta" | awk '{print $4}')
            [[ -z "$size" || "$size" == "-" ]] && continue

            # Only check JS/TS files
            [[ "$path" != *.js && "$path" != *.mjs && "$path" != *.cjs && "$path" != *.ts ]] && continue

            # Skip known build/vendor directories
            [[ "$path" == *"node_modules"* ]] && continue
            [[ "$path" == *"vendor"* ]] && continue
            [[ "$path" == *"dist/"* ]] && continue
            [[ "$path" == *"build/"* ]] && continue
            [[ "$path" == *".min.js" ]] && continue

            if [[ "$size" -gt "$LARGE_JS_THRESHOLD" ]]; then
                found_any=true
                local size_mb
                size_mb=$(echo "scale=1; $size / 1048576" | bc 2>/dev/null || echo "?")
                log_critical "ABNORMALLY LARGE JS FILE in ${CYAN}${ref_short}${NC}:${path}"
                log_critical "  └─ Size: ${size} bytes (${size_mb} MB) — Shai-Hulud payloads can be 9MB+"

                # Check hash against known payloads
                local file_hash
                file_hash=$(git -C "$repo_path" show "${ref}:${path}" 2>/dev/null | sha256sum | awk '{print $1}')
                for known_hash in "${KNOWN_HASHES[@]}"; do
                    if [[ "$file_hash" == "$known_hash" ]]; then
                        log_critical "  └─ SHA256 MATCH: confirmed Shai-Hulud payload"
                        break
                    fi
                done
            fi
        done < <(git -C "$repo_path" ls-tree -l -r "$ref" 2>/dev/null || true)
    done

    if [[ "$found_any" == false ]]; then
        echo "  No abnormally large JS files found across any branch."
    fi
}

# ─────────────────────────────────────────────────────────────
# Cleanup mode
# ─────────────────────────────────────────────────────────────

cleanup_print_warning() {
    echo ""
    echo -e "${RED}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║           ⚠  CLEANUP MODE — REWRITES GIT HISTORY  ⚠         ║${NC}"
    echo -e "${RED}║                                                              ║${NC}"
    echo -e "${RED}║  This will:                                                  ║${NC}"
    echo -e "${RED}║    1. Find infected files on the CURRENT branch              ║${NC}"
    echo -e "${RED}║    2. Restore them from the last clean commit                ║${NC}"
    echo -e "${RED}║    3. Create a fix commit                                    ║${NC}"
    echo -e "${RED}║    4. Require a FORCE-PUSH to update the remote              ║${NC}"
    echo -e "${RED}║                                                              ║${NC}"
    echo -e "${RED}║  Force-pushing OVERWRITES remote history.                    ║${NC}"
    echo -e "${RED}║  All developers MUST re-pull after cleanup.                  ║${NC}"
    echo -e "${RED}║  Commits on top of infected history may be LOST.             ║${NC}"
    echo -e "${RED}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
}

# Find infected files on the current branch working tree
cleanup_find_infected() {
    local repo_path="$1"
    local malware_pattern="global\.i=['\"][0-9]+-[0-9]+(-[0-9]+)?['\"]"
    local obfuscation_pattern='[^[:space:]][[:space:]]{50,}[^[:space:]]'

    echo -e "${BLUE}Scanning current branch for infected files...${NC}"
    echo ""

    local current_branch
    current_branch=$(git -C "$repo_path" branch --show-current 2>/dev/null || echo "HEAD")
    echo -e "  Branch: ${CYAN}${current_branch}${NC}"
    echo ""

    INFECTED_FILES=()

    # Search for malware signatures in all JS/TS files
    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        [[ "$file" == *"node_modules"* ]] && continue
        [[ "$file" == *"vendor"* ]] && continue
        [[ "$file" == *"dist/"* ]] && continue
        [[ "$file" == *".min.js" ]] && continue

        local strain
        strain=$(grep -oE "global\.i=['\"][0-9]+-[0-9]+(-[0-9]+)?['\"]" "$repo_path/$file" 2>/dev/null | head -1 || true)
        local size
        size=$(wc -c < "$repo_path/$file" 2>/dev/null || echo 0)

        INFECTED_FILES+=("$file")
        echo -e "  ${RED}INFECTED:${NC} $file"
        [[ -n "$strain" ]] && echo -e "    Strain: ${RED}${strain}${NC}"
        echo -e "    Size: ${RED}${size} bytes${NC}"
    done < <(grep -rlE "$malware_pattern" "$repo_path" --include='*.js' --include='*.ts' --include='*.mjs' --include='*.cjs' 2>/dev/null \
        | sed "s|^$repo_path/||" || true)

    # Also check for whitespace obfuscation without signature
    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        [[ "$file" == *"node_modules"* ]] && continue
        [[ "$file" == *"vendor"* ]] && continue
        [[ "$file" == *"dist/"* ]] && continue
        [[ "$file" == *".min.js" ]] && continue

        # Skip if already found by signature scan
        local already_found=false
        for inf in "${INFECTED_FILES[@]}"; do
            [[ "$inf" == "$file" ]] && already_found=true && break
        done
        [[ "$already_found" == true ]] && continue

        local size
        size=$(wc -c < "$repo_path/$file" 2>/dev/null || echo 0)

        INFECTED_FILES+=("$file")
        echo -e "  ${RED}SUSPICIOUS:${NC} $file"
        echo -e "    Whitespace obfuscation detected (no known strain signature)"
        echo -e "    Size: ${RED}${size} bytes${NC}"
    done < <(grep -rlE "$obfuscation_pattern" "$repo_path" --include='*.js' --include='*.ts' --include='*.mjs' --include='*.cjs' 2>/dev/null \
        | sed "s|^$repo_path/||" || true)

    echo ""

    if [[ ${#INFECTED_FILES[@]} -eq 0 ]]; then
        echo -e "${GREEN}No infected files found on current branch. Nothing to clean.${NC}"
        return 1
    fi

    echo -e "  Found ${RED}${#INFECTED_FILES[@]}${NC} infected file(s)"
    return 0
}

# Find the last clean version of a file in git history
cleanup_find_clean_commit() {
    local repo_path="$1"
    local file="$2"
    local malware_pattern="global\.i=['\"][0-9]+-[0-9]+(-[0-9]+)?['\"]"
    local obfuscation_pattern='[[:space:]]{50,}'

    echo -e "  Searching history for clean version of ${CYAN}${file}${NC}..."

    # Get commits that touched this file, oldest first
    local commits
    commits=$(git -C "$repo_path" log --oneline --follow -- "$file" 2>/dev/null | awk '{print $1}')

    for commit in $commits; do
        local content
        content=$(git -C "$repo_path" show "${commit}:${file}" 2>/dev/null || true)
        [[ -z "$content" ]] && continue

        # Check if this version is clean
        if ! echo "$content" | grep -qE "$malware_pattern" 2>/dev/null; then
            if ! echo "$content" | grep -qE "$obfuscation_pattern" 2>/dev/null; then
                local size
                size=$(echo "$content" | wc -c)
                echo -e "    Found clean version at commit ${GREEN}${commit}${NC} (${size} bytes)"
                echo "$commit"
                return 0
            fi
        fi
    done

    echo -e "    ${RED}No clean version found in git history${NC}"
    return 1
}

# Restore infected files from clean commits
cleanup_restore_files() {
    local repo_path="$1"
    shift
    local files=("$@")

    echo ""
    echo -e "${BLUE}Restoring clean versions...${NC}"
    echo ""

    local restored=0
    local failed=0
    local file clean_commit old_size new_size

    for file in "${files[@]}"; do
        clean_commit=$(cleanup_find_clean_commit "$repo_path" "$file" | tail -1)

        if [[ -n "$clean_commit" && "$clean_commit" != *"No clean"* && "$clean_commit" != *"Searching"* && "$clean_commit" != *"Found"* ]]; then
            # Show before/after
            old_size=$(wc -c < "$repo_path/$file" 2>/dev/null || echo 0)

            git -C "$repo_path" show "${clean_commit}:${file}" > "$repo_path/$file" 2>/dev/null
            new_size=$(wc -c < "$repo_path/$file" 2>/dev/null || echo 0)

            echo -e "    ${GREEN}RESTORED:${NC} $file"
            echo -e "      ${RED}${old_size}${NC} bytes → ${GREEN}${new_size}${NC} bytes (from commit ${clean_commit})"
            ((restored++)) || true
        else
            echo -e "    ${RED}FAILED:${NC} $file — no clean version found"
            echo -e "      Manual intervention required: rewrite the file from scratch"
            ((failed++)) || true
        fi
    done

    echo ""
    echo -e "  Restored: ${GREEN}${restored}${NC}  Failed: ${RED}${failed}${NC}"

    if [[ $restored -eq 0 ]]; then
        echo -e "${RED}No files were restored. Aborting.${NC}"
        return 1
    fi

    return 0
}

# Commit the cleanup and prompt for force-push
cleanup_commit_and_push() {
    local repo_path="$1"

    echo ""
    echo -e "${BLUE}Staging cleaned files...${NC}"

    local current_branch
    current_branch=$(git -C "$repo_path" branch --show-current 2>/dev/null || echo "unknown")

    # Show what will be committed
    git -C "$repo_path" diff --stat

    echo ""
    echo -en "${YELLOW}Commit these changes? [y/N] ${NC}"
    read -r confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Aborted. Files are restored but not committed."
        echo "You can commit manually: cd $repo_path && git add -A && git commit"
        return 0
    fi

    # Stage and commit
    for file in "${INFECTED_FILES[@]}"; do
        git -C "$repo_path" add "$file" 2>/dev/null || true
    done

    local strains_found
    strains_found=$(printf '%s\n' "${INFECTED_FILES[@]}" | head -5 | tr '\n' ', ' | sed 's/,$//')

    git -C "$repo_path" commit -m "fix: remove Shai-Hulud malware from infected files

Cleaned files: ${strains_found}
Restored from last known clean commits in git history.

Scanner: shai-hulud-scanner/detect-config-malware.sh --cleanup" 2>/dev/null

    echo ""
    echo -e "${GREEN}Commit created.${NC}"
    echo ""
    echo -e "${RED}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║              FORCE-PUSH REQUIRED                            ║${NC}"
    echo -e "${RED}║                                                              ║${NC}"
    echo -e "${RED}║  The infected commits are still in remote history.           ║${NC}"
    echo -e "${RED}║  You MUST force-push to overwrite them:                      ║${NC}"
    echo -e "${RED}║                                                              ║${NC}"
    echo -e "${RED}║    git push --force-with-lease origin ${current_branch}${NC}"
    echo -e "${RED}║                                                              ║${NC}"
    echo -e "${RED}║  After force-push, ALL developers must:                      ║${NC}"
    echo -e "${RED}║    git fetch --all                                           ║${NC}"
    echo -e "${RED}║    git reset --hard origin/${current_branch}${NC}"
    echo -e "${RED}║                                                              ║${NC}"
    echo -e "${RED}║  Any commits they made on top of infected history will       ║${NC}"
    echo -e "${RED}║  need to be cherry-picked onto the clean branch.             ║${NC}"
    echo -e "${RED}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -en "${YELLOW}Force-push now? [y/N] ${NC}"
    read -r push_confirm
    if [[ "$push_confirm" == "y" || "$push_confirm" == "Y" ]]; then
        echo -e "${YELLOW}Pushing...${NC}"
        git -C "$repo_path" push --force-with-lease origin "$current_branch"
        echo -e "${GREEN}Force-push complete.${NC}"
    else
        echo ""
        echo "Run manually when ready:"
        echo "  cd $repo_path && git push --force-with-lease origin $current_branch"
    fi
}

# Main cleanup flow
run_cleanup() {
    local repo_path="$1"

    cleanup_print_warning

    echo -en "${YELLOW}Continue with cleanup? [y/N] ${NC}"
    read -r confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Aborted."
        exit 0
    fi

    echo ""

    # Step 1: Find infected files
    if ! cleanup_find_infected "$repo_path"; then
        exit 0
    fi

    # Step 2: Confirm files to clean
    echo ""
    echo -en "${YELLOW}Restore these files from clean git history? [y/N] ${NC}"
    read -r confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Aborted."
        exit 0
    fi

    # Step 3: Restore from clean commits
    if ! cleanup_restore_files "$repo_path" "${INFECTED_FILES[@]}"; then
        exit 1
    fi

    # Step 4: Commit and push
    cleanup_commit_and_push "$repo_path"

    echo ""
    echo -e "${GREEN}Cleanup complete. Run the scanner again to verify:${NC}"
    echo "  $0 $repo_path"
}

# ─────────────────────────────────────────────────────────────
# Summary and main
# ─────────────────────────────────────────────────────────────

print_summary() {
    echo ""
    echo -e "${BLUE}════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}                         SCAN SUMMARY                           ${NC}"
    echo -e "${BLUE}════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo "Config files scanned: $FILES_SCANNED"
    if [[ "$ALL_BRANCHES" == true ]]; then
        echo "Mode: All branches"
    else
        echo "Mode: Current branch"
    fi
    echo ""

    if [[ "$ISSUES_FOUND" -eq 0 ]]; then
        log_success "No issues detected"
    else
        echo -e "${RED}Issues found: $ISSUES_FOUND${NC}"
        echo ""
        echo "Recommended actions:"
        echo "  1. Review flagged files manually"
        echo "  2. Check git history for recent changes to these files"
        echo "  3. Compare file sizes with known-good versions"
        echo "  4. If malware signature found, isolate and investigate immediately"
    fi
    echo ""
}

main() {
    if [[ $# -lt 1 ]]; then
        print_usage
        exit 1
    fi

    local repo_path=""

    # Parse arguments
    for arg in "$@"; do
        case "$arg" in
            --verbose) VERBOSE=true ;;
            --all-branches) ALL_BRANCHES=true; CURRENT_BRANCH_ONLY=false ;;
            --current-branch) CURRENT_BRANCH_ONLY=true; ALL_BRANCHES=false ;;
            --cleanup) CLEANUP_MODE=true ;;
            --help|-h)
                print_usage
                exit 0
                ;;
            *)
                if [[ -z "$repo_path" ]]; then
                    repo_path="$arg"
                elif [[ "$arg" == --* || "$arg" == -* ]]; then
                    echo -e "${RED}Error: Unknown option: $arg${NC}" >&2
                    print_usage >&2
                    exit 1
                fi
                ;;
        esac
    done

    if [[ -z "$repo_path" ]]; then
        print_usage
        exit 1
    fi

    # Validate repo path
    if [[ ! -d "$repo_path" ]]; then
        echo -e "${RED}Error: Directory not found: $repo_path${NC}"
        exit 1
    fi

    # Cleanup mode — interactive restore from git history
    if [[ "$CLEANUP_MODE" == true ]]; then
        print_header
        run_cleanup "$repo_path"
        exit 0
    fi

    # Detection mode (default)
    print_header

    # If not a git repo, report error and scan subdirectories for git repos
    if [[ ! -d "$repo_path/.git" ]]; then
        echo -e "${RED}[ERROR]${NC} Not a git repository: $repo_path"
        echo ""

        # Discover git repos in subdirectories
        local sub_repos=()
        while IFS= read -r gitdir; do
            [[ -z "$gitdir" ]] && continue
            sub_repos+=("$(dirname "$gitdir")")
        done < <(find "$repo_path" -maxdepth 3 -name ".git" -type d 2>/dev/null | sort)

        if [[ ${#sub_repos[@]} -gt 0 ]]; then
            echo -e "${BLUE}Found ${#sub_repos[@]} git repo(s) in subdirectories:${NC}"
            for sub in "${sub_repos[@]}"; do
                echo "  $sub"
            done
            echo ""

            for sub in "${sub_repos[@]}"; do
                echo -e "${BLUE}════════════════════════════════════════════════════════════════${NC}"
                if [[ "$ALL_BRANCHES" == true ]]; then
                    scan_repo_all_branches "$sub"
                else
                    scan_repo_current_branch "$sub"
                fi
                echo ""
            done
        else
            echo -e "${YELLOW}[WARN]${NC} No git repos found in subdirectories, scanning as plain directory"
            scan_repo_worktree "$repo_path"
        fi
    else
        if [[ "$ALL_BRANCHES" == true ]]; then
            scan_repo_all_branches "$repo_path"
        else
            scan_repo_current_branch "$repo_path"
        fi
    fi

    print_summary

    if [[ "$ISSUES_FOUND" -gt 0 ]]; then
        exit 1
    fi
}

main "$@"
